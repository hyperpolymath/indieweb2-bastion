= Architecture - indieweb2-bastion
:toc: macro
:toclevels: 3
:icons: font

[abstract]
--
System architecture documentation for indieweb2-bastion (IndieWeb2 consent-first DNS/identity platform). Includes C4 diagrams, multi-chain integration, technology stack, and deployment strategies. Required by Rhodium Standard 0.5 (Gold level, Pillar 1, Section 2.1.4).
--

toc::[]

== Overview

**indieweb2-bastion** is a consent-first DNS and identity platform built around privacy, provenance, and decentralization. It combines traditional infrastructure (DNS, GraphQL APIs) with blockchain-based identity and Web3 integration.

**Architecture Style:** Microservices with blockchain integration
**Primary Components:**
* Bastion ingress gateway (Envoy, mTLS)
* oDNS (Oblivious DNS) with IPv6
* GraphQL DNS API
* SurrealDB provenance graph
* Multi-chain identity anchoring (Ethereum, Polygon, Internet Computer)
* Browser extensions and CMS plugins

**Key Technologies:**
* **Frontend:** ReScript 11.0.1, React
* **Backend:** Go (Bastion), DNS servers (BIND/CoreDNS)
* **Database:** SurrealDB
* **Blockchain:** Solidity 0.8.x (Ethereum/Polygon), Motoko 0.10.x (IC)
* **Infrastructure:** Podman, Envoy, WASM policies

== C4 Architecture Diagrams

=== Level 1: System Context

[plantuml, indieweb2-context, svg]
----
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

LAYOUT_WITH_LEGEND()

title System Context - indieweb2-bastion

Person(user, "Web User", "Browsing IndieWeb sites")
Person(publisher, "Content Publisher", "Manages identity and content")

System(bastion, "indieweb2-bastion", "Consent-first DNS + Identity platform")

System_Ext(dns, "Upstream DNS", "Traditional DNS resolvers")
System_Ext(ipfs, "IPFS/IPNS", "Decentralized storage")
System_Ext(ethereum, "Ethereum", "Smart contracts for identity")
System_Ext(polygon, "Polygon", "L2 scaling for identity")
System_Ext(ic, "Internet Computer", "Decentralized hosting")
System_Ext(cms, "CMS Platforms", "WordPress, Ghost, Hugo")

Rel(user, bastion, "Browsing with consent", "HTTPS/DNS")
Rel(publisher, bastion, "Publishes identity", "GraphQL API")
Rel(bastion, dns, "Resolves", "DNS over TLS")
Rel(bastion, ipfs, "Stores provenance", "IPFS/IPNS")
Rel(bastion, ethereum, "Anchors identity", "Web3")
Rel(bastion, polygon, "Anchors identity", "Web3")
Rel(bastion, ic, "Hosts canisters", "IC SDK")
Rel(publisher, cms, "Authors content", "Admin UI")
Rel(cms, bastion, "Publishes manifests", "Plugin")

@enduml
----

**Key External Systems:**
* **Upstream DNS:** Traditional DNS for resolution (fallback)
* **IPFS/IPNS:** Decentralized storage for provenance graphs
* **Ethereum/Polygon/IC:** Blockchain identity anchoring
* **CMS Platforms:** WordPress, Ghost, Hugo integrations

=== Level 2: Container Diagram

[plantuml, indieweb2-container, svg]
----
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

LAYOUT_WITH_LEGEND()

title Container Diagram - indieweb2-bastion

Person(user, "Web User")
Person(publisher, "Publisher")

System_Boundary(bastion_system, "indieweb2-bastion") {
    Container(gateway, "Bastion Gateway", "Envoy Proxy", "mTLS, rate limiting, consent checks")
    Container(odns_proxy, "oDNS Proxy", "Go", "Encrypted DNS queries (HPKE)")
    Container(odns_resolver, "oDNS Resolver", "CoreDNS", "Resolves DNS without client IP")
    Container(graphql, "GraphQL DNS API", "Node.js/Go", "Full RR coverage, DNSSEC")
    Container(frontend, "Web Frontend", "ReScript + React", "Consent UI, provenance badges")
    Container(contract_eth, "Identity Contracts", "Solidity", "Ethereum/Polygon smart contracts")
    Container(contract_ic, "IC Canisters", "Motoko", "Internet Computer identity")
    ContainerDb(surrealdb, "SurrealDB", "Graph Database", "Provenance graph, manifests")
}

System_Ext(ipfs, "IPFS")
System_Ext(ethereum, "Ethereum")
System_Ext(polygon, "Polygon")
System_Ext(ic, "Internet Computer")

Rel(user, gateway, "HTTPS", "TLS 1.3")
Rel(user, frontend, "Loads", "HTTPS")
Rel(publisher, graphql, "Publishes", "GraphQL")
Rel(gateway, odns_proxy, "DNS Query", "DoH/DoT")
Rel(odns_proxy, odns_resolver, "HPKE Encrypted", "UDP/TCP")
Rel(graphql, surrealdb, "Reads/Writes", "WS")
Rel(frontend, graphql, "Queries", "GraphQL")
Rel(surrealdb, ipfs, "Exports snapshots", "IPFS API")
Rel(contract_eth, ethereum, "Deploys to")
Rel(contract_eth, polygon, "Deploys to")
Rel(contract_ic, ic, "Runs on")
Rel(graphql, contract_eth, "Reads identity", "Web3.js")
Rel(graphql, contract_ic, "Reads identity", "IC SDK")

@enduml
----

**Containers:**
* **Bastion Gateway (Envoy):** mTLS enforcement, rate limiting, consent validation
* **oDNS Proxy:** Encrypts DNS queries with HPKE before forwarding
* **oDNS Resolver:** Resolves DNS without seeing client IP (oblivious)
* **GraphQL DNS API:** Full DNS record type coverage, DNSSEC management
* **Web Frontend (ReScript):** Consent banners, provenance badges
* **Smart Contracts:** Identity anchoring on Ethereum/Polygon/IC
* **SurrealDB:** Graph database for identity provenance

=== Level 3: Component Diagram (Bastion Gateway)

[plantuml, bastion-components, svg]
----
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

LAYOUT_WITH_LEGEND()

title Component Diagram - Bastion Gateway

Container_Boundary(gateway, "Bastion Gateway") {
    Component(listener, "Listener", "Envoy", "TLS termination, HTTP/2")
    Component(auth, "Auth Filter", "Envoy Filter", "mTLS validation, JWT")
    Component(rate_limit, "Rate Limiter", "Envoy Filter", "Token bucket per IP")
    Component(consent, "Consent Checker", "WASM Policy", "Validates user consent")
    Component(router, "Router", "Envoy", "Routes to backend services")
    Component(metrics, "Metrics Exporter", "Prometheus", "Telemetry")
}

Container(odns, "oDNS Proxy")
Container(graphql, "GraphQL API")
Container(frontend, "Frontend")

Rel(listener, auth, "Validates")
Rel(auth, rate_limit, "Passes")
Rel(rate_limit, consent, "Checks")
Rel(consent, router, "Routes")
Rel(router, odns, "DNS queries")
Rel(router, graphql, "API requests")
Rel(router, frontend, "Static assets")
Rel(listener, metrics, "Exports")

@enduml
----

**Key Components:**
* **Listener:** TLS 1.3 termination, HTTP/2 support
* **Auth Filter:** mTLS client certificate validation, JWT tokens
* **Rate Limiter:** Per-IP token bucket (100 req/min default)
* **Consent Checker:** WASM-compiled policy engine (CURPS)
* **Router:** Routes to appropriate backend services
* **Metrics Exporter:** Prometheus metrics for monitoring

== Technology Stack

=== Core Technologies

[cols="1,2,1"]
|===
|Component |Technology |Version

|Frontend
|ReScript
|11.0.1

|Frontend Runtime
|React
|18.x

|Backend (Gateway)
|Envoy Proxy
|1.28+

|Backend (API)
|Go / Node.js
|1.21+ / 20.x

|DNS Resolver
|CoreDNS
|1.11+

|Database
|SurrealDB
|1.x

|Smart Contracts (EVM)
|Solidity
|0.8.x

|Smart Contracts (IC)
|Motoko
|0.10.x

|Policy Engine
|WASM (compiled from Rego/CURPS)
|WASM 1.0

|Container Runtime
|Podman
|4.x

|===

=== Blockchain Stack

**Ethereum/Polygon:**
* Solidity 0.8.x (smart contracts)
* Hardhat 2.x (development framework)
* OpenZeppelin Contracts 5.x (libraries)
* ethers.js 6.x (Web3 client)

**Internet Computer:**
* Motoko 0.10.x (smart contracts/canisters)
* dfx 0.15+ (IC SDK)
* IC agent-js (frontend integration)

=== Infrastructure

[source,yaml]
----
# Podman compose example
services:
  bastion-gateway:
    image: envoyproxy/envoy:v1.28-latest
    volumes:
      - ./config/envoy.yaml:/etc/envoy/envoy.yaml
    ports:
      - "443:443"
      - "853:853"  # DNS over TLS

  odns-proxy:
    build: ./odns-proxy
    environment:
      - HPKE_PUBLIC_KEY=/secrets/hpke.pub

  surrealdb:
    image: surrealdb/surrealdb:latest
    command: start --user root --pass root
----

== System Architecture

=== Bastion Gateway Architecture

**Envoy Configuration:**

[source,yaml]
----
# config/envoy.yaml
static_resources:
  listeners:
    - name: https_listener
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 443
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                http_filters:
                  - name: envoy.filters.http.wasm
                    typed_config:
                      '@type': type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
                      config:
                        vm_config:
                          runtime: envoy.wasm.runtime.v8
                          code:
                            local:
                              filename: /etc/envoy/consent-policy.wasm
                  - name: envoy.filters.http.ratelimit
                  - name: envoy.filters.http.router
          transport_socket:
            name: envoy.transport_sockets.tls
            typed_config:
              '@type': type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
              require_client_certificate: true
----

**mTLS Enforcement:**
* Client certificates required for admin APIs
* Public endpoints use server-only TLS
* Certificate rotation: 90-day validity

=== oDNS (Oblivious DNS) Architecture

**How oDNS Works:**

[source]
----
Client
  ↓ (encrypted query with HPKE)
oDNS Proxy
  ↓ (forwards without client IP)
oDNS Resolver
  ↓ (standard DNS)
Upstream DNS
  ↓ (response)
oDNS Resolver
  ↓ (encrypted response)
oDNS Proxy
  ↓ (decrypted response)
Client
----

**Privacy Guarantees:**
* Proxy sees client IP but NOT query content (HPKE encrypted)
* Resolver sees query content but NOT client IP
* Ephemeral node rotation every 24 hours
* No query logging (tamper-evident empty logs)

**HPKE (Hybrid Public Key Encryption):**
[source,go]
----
// odns-proxy/encrypt.go
func encryptQuery(query []byte, publicKey *hpke.PublicKey) ([]byte, error) {
    suite := hpke.NewSuite(hpke.X25519, hpke.HKDF_SHA256, hpke.ChaCha20Poly1305)
    sender, err := suite.NewSender(publicKey, nil)
    if err != nil {
        return nil, err
    }
    return sender.Seal(query)
}
----

=== GraphQL DNS API

**Schema:**

[source,graphql]
----
type DNSRecord {
  id: ID!
  name: String!
  type: DNSRecordType!
  ttl: Int!
  value: String!
  dnssec: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum DNSRecordType {
  A
  AAAA
  CNAME
  MX
  TXT
  SRV
  CAA
  TLSA
}

type Query {
  dnsRecord(id: ID!): DNSRecord
  dnsRecords(name: String, type: DNSRecordType): [DNSRecord!]!
  reverseDNS(ip: String!): [DNSRecord!]!
}

type Mutation {
  createDNSRecord(input: DNSRecordInput!): DNSRecord!
  updateDNSRecord(id: ID!, input: DNSRecordInput!): DNSRecord!
  deleteDNSRecord(id: ID!): Boolean!
  enableDNSSEC(zone: String!): Boolean!
}
----

**Implementation:**

[source,typescript]
----
// graphql-api/resolvers/dns.ts
export const resolvers = {
  Query: {
    dnsRecords: async (_, { name, type }, { db }) => {
      return await db.query(
        'SELECT * FROM dns_records WHERE name = $name AND type = $type',
        { name, type }
      );
    }
  },
  Mutation: {
    createDNSRecord: async (_, { input }, { db, blockchain }) => {
      // Create DNS record in SurrealDB
      const record = await db.create('dns_records', input);

      // Anchor hash to blockchain for provenance
      await blockchain.anchorHash(record.id, record.hash);

      return record;
    }
  }
};
----

=== SurrealDB Provenance Graph

**Schema:**

[source,surql]
----
-- Identity node
DEFINE TABLE identity SCHEMAFULL;
DEFINE FIELD did ON identity TYPE string;
DEFINE FIELD ethereum_address ON identity TYPE string;
DEFINE FIELD ic_principal ON identity TYPE string;
DEFINE FIELD created_at ON identity TYPE datetime DEFAULT time::now();

-- Manifest node
DEFINE TABLE manifest SCHEMAFULL;
DEFINE FIELD url ON manifest TYPE string;
DEFINE FIELD content_hash ON manifest TYPE string;
DEFINE FIELD ipfs_cid ON manifest TYPE string;
DEFINE FIELD published_at ON manifest TYPE datetime;

-- Provenance edge
DEFINE TABLE published SCHEMAFULL TYPE RELATION FROM identity TO manifest;
DEFINE FIELD timestamp ON published TYPE datetime;
DEFINE FIELD signature ON published TYPE string;

-- Query examples
SELECT * FROM identity WHERE ethereum_address = "0x123...";
SELECT ->published->manifest FROM identity:did123;
----

**Export to IPFS:**

[source,javascript]
----
// surrealdb/export.js
async function exportProvenanceGraph() {
  const graph = await db.query('SELECT * FROM identity, manifest, published');
  const jsonld = convertToJSONLD(graph);

  const ipfs = create({ url: 'https://ipfs.infura.io:5001' });
  const { cid } = await ipfs.add(JSON.stringify(jsonld));

  console.log(`Provenance graph exported to IPFS: ${cid}`);
  return cid;
}
----

=== Blockchain Integration

==== Ethereum/Polygon Identity Contracts

[source,solidity]
----
// contracts/Identity.sol
pragma solidity ^0.8.0;

contract IdentityRegistry {
    struct Identity {
        string did;
        bytes32 contentHash;
        uint256 timestamp;
        bool verified;
    }

    mapping(address => Identity) public identities;

    event IdentityRegistered(address indexed owner, string did, bytes32 contentHash);
    event IdentityVerified(address indexed owner, string did);

    function registerIdentity(string memory _did, bytes32 _contentHash) external {
        require(bytes(identities[msg.sender].did).length == 0, "Identity already exists");

        identities[msg.sender] = Identity({
            did: _did,
            contentHash: _contentHash,
            timestamp: block.timestamp,
            verified: false
        });

        emit IdentityRegistered(msg.sender, _did, _contentHash);
    }

    function verifyIdentity(address _owner) external onlyAdmin {
        require(bytes(identities[_owner].did).length > 0, "Identity not found");
        identities[_owner].verified = true;
        emit IdentityVerified(_owner, identities[_owner].did);
    }

    function getIdentity(address _owner) external view returns (Identity memory) {
        return identities[_owner];
    }
}
----

**Deployment:**
[source,bash]
----
# Deploy to Sepolia testnet
npx hardhat run scripts/deploy.js --network sepolia

# Deploy to Polygon mainnet
npx hardhat run scripts/deploy.js --network polygon
----

==== Internet Computer Canisters

[source,motoko]
----
// ic/identity-canister/main.mo
import Principal "mo:base/Principal";
import HashMap "mo:base/HashMap";
import Text "mo:base/Text";
import Time "mo:base/Time";

actor IdentityCanister {
  type Identity = {
    did: Text;
    contentHash: Text;
    timestamp: Time.Time;
    verified: Bool;
  };

  stable var identities = HashMap.HashMap<Principal, Identity>(10, Principal.equal, Principal.hash);

  public shared(msg) func registerIdentity(did: Text, contentHash: Text) : async () {
    let caller = msg.caller;
    let identity : Identity = {
      did = did;
      contentHash = contentHash;
      timestamp = Time.now();
      verified = false;
    };
    identities.put(caller, identity);
  };

  public query func getIdentity(owner: Principal) : async ?Identity {
    identities.get(owner);
  };
};
----

**Deployment:**
[source,bash]
----
# Deploy to IC mainnet
dfx deploy --network ic identity-canister
----

== Frontend Architecture (ReScript)

**Component Structure:**

[source,rescript]
----
// src/components/ConsentBanner.res
@react.component
let make = (~onAccept, ~onReject) => {
  <div className="consent-banner">
    <p> {React.string("This site uses consent-first tracking.")} </p>
    <button onClick={_ => onAccept()}> {React.string("Accept")} </button>
    <button onClick={_ => onReject()}> {React.string("Reject")} </button>
  </div>
}
----

**GraphQL Integration:**

[source,rescript]
----
// src/api/IdentityAPI.res
module GetIdentity = %graphql(`
  query GetIdentity($address: String!) {
    identity(ethereumAddress: $address) {
      did
      contentHash
      verified
    }
  }
`)

let fetchIdentity = async (address: string) => {
  let result = await GetIdentity.use({address: address})
  result.identity
}
----

== Deployment Architecture

=== Development Environment

[source,bash]
----
# Start all services with Podman Compose
podman-compose up -d

# Access services
# Gateway: https://localhost:443
# GraphQL: https://localhost:443/graphql
# SurrealDB: ws://localhost:8000
----

=== Production Deployment (Kubernetes)

[source,yaml]
----
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: bastion-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: bastion-gateway
  template:
    metadata:
      labels:
        app: bastion-gateway
    spec:
      containers:
        - name: envoy
          image: envoyproxy/envoy:v1.28
          ports:
            - containerPort: 443
            - containerPort: 853
          volumeMounts:
            - name: envoy-config
              mountPath: /etc/envoy
            - name: tls-certs
              mountPath: /etc/tls
      volumes:
        - name: envoy-config
          configMap:
            name: envoy-config
        - name: tls-certs
          secret:
            secretName: tls-certs
----

=== Blockchain Deployment

**Ethereum/Polygon:**
* Deployed via Hardhat scripts
* Proxy pattern (EIP-1967) for upgradeability
* Multi-sig admin (Gnosis Safe)
* Sepolia testnet for staging

**Internet Computer:**
* Deployed via dfx
* Canister upgrades with stable memory
* Threshold signatures for governance

== Data Flow

=== DNS Query Flow (with oDNS)

[source]
----
1. Client generates DNS query for "example.com"
2. Query encrypted with oDNS Proxy public key (HPKE)
3. Encrypted query sent to oDNS Proxy
4. Proxy forwards to Resolver (without client IP)
5. Resolver decrypts, performs standard DNS lookup
6. Response encrypted and returned to Proxy
7. Proxy decrypts and returns to Client
----

=== Identity Registration Flow

[source]
----
1. Publisher connects wallet (MetaMask/IC Plug)
2. GraphQL API verifies wallet signature
3. Identity record created in SurrealDB
4. Smart contract registerIdentity() called
5. Transaction confirmed on-chain
6. Provenance graph updated
7. IPFS snapshot generated
----

=== Consent Flow

[source]
----
1. User visits site with Bastion protection
2. Envoy consent checker (WASM) verifies consent cookie
3. If no consent: Redirect to consent banner
4. User accepts/rejects tracking
5. Consent stored in cookie + SurrealDB
6. Request proceeds or is modified based on consent
----

== Security Architecture

=== mTLS Enforcement

[source,bash]
----
# Generate CA and certificates
openssl req -x509 -newkey rsa:4096 -keyout ca-key.pem -out ca-cert.pem -days 365

# Client certificate
openssl req -newkey rsa:4096 -keyout client-key.pem -out client-req.pem
openssl x509 -req -in client-req.pem -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -out client-cert.pem
----

=== Smart Contract Security

**Audit Checklist:**
* [ ] Reentrancy guards on all external calls
* [ ] Integer overflow protection (Solidity 0.8+)
* [ ] Access control (Ownable, Role-based)
* [ ] Pausable for emergency stops
* [ ] Event emission for all state changes
* [ ] Gas optimization (avoid loops)

**Example:**
[source,solidity]
----
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract SecureIdentity is ReentrancyGuard, Pausable {
    function registerIdentity() external nonReentrant whenNotPaused {
        // Safe from reentrancy
    }
}
----

== Monitoring and Observability

=== Prometheus Metrics

[source,yaml]
----
# metrics.yaml
- name: http_requests_total
  type: counter
  help: Total HTTP requests by status code
  labels: [method, status]

- name: dns_query_duration_seconds
  type: histogram
  help: DNS query latency
  buckets: [0.001, 0.01, 0.1, 1.0]

- name: blockchain_tx_confirmations
  type: gauge
  help: Blockchain transaction confirmations
  labels: [chain, contract]
----

=== Health Checks

[source,yaml]
----
# k8s/healthcheck.yaml
livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 5
----

== Performance Considerations

**DNS Resolution:**
* Target latency: <50ms (without oDNS), <100ms (with oDNS)
* Caching: 300s TTL for common queries
* IPv6-native for reduced hops

**Blockchain Transactions:**
* Ethereum L1: ~12s confirmation (1 block)
* Polygon: ~2s confirmation (1 block)
* Internet Computer: <2s finality

**GraphQL API:**
* Target p99: <200ms
* Rate limiting: 100 req/min per IP
* Connection pooling to SurrealDB

== WASM Strategy

**Current WASM Usage:**
* Consent policy engine (CURPS → WASM)
* Portable enforcement across Envoy, browser extension
* Compiled with wasm-pack (Rust → WASM)

**Future WASM Plans:**
* Full ReScript → WASM compilation (ReScript → OCaml → WASM)
* Smart contract logic verification in browser
* Offline-first identity verification

**Waiver:** Waiver-2025-006 acknowledges blockchain immutability as exception to full WASM portability.

== References

* link:https://datatracker.ietf.org/doc/draft-ietf-dprive-oblivious-dns/[Oblivious DNS RFC Draft]
* link:https://www.envoyproxy.io/docs/envoy/latest/[Envoy Proxy Documentation]
* link:https://surrealdb.com/docs[SurrealDB Documentation]
* link:https://eips.ethereum.org/EIPS/eip-1967[EIP-1967 Proxy Standard]
* link:https://internetcomputer.org/docs/current/developer-docs/[Internet Computer Docs]
* link:https://rescript-lang.org/docs/manual/latest/introduction[ReScript Documentation]
* link:docs/adr/0002-multi-chain-architecture.adoc[ADR-0002: Multi-Chain Architecture]
* link:../REVERSIBILITY.adoc[Reversibility and Rollback Procedures]

---

_This document complies with Rhodium Standard 0.5 (Gold level), Pillar 1, Section 2.1.4 (Architecture Documentation)._

_Last Updated: 2025-01-21_
_Repository: indieweb2-bastion (Multi-chain identity + oDNS platform)_
